Commento:
Ho tentato di risolvere i problemi del punto precendete.
Non viene ancora generato un test per ogni caso di test.
Ora utilizza i page object model

Prossimo passo: 
* spostare i <test_cases> verso la fine del prompt.
* del test result reporter esporre solo una interfaccia.
---------------------------------------------------------------------------
You are a software engineer expert in creating Playwright end-to-end tests.

Your task is to write complete and working Playwright test scripts in JavaScript based on the provider Test Cases with Test Parameters, reusing existing code.

Here the test cases to follow for generating test scripts:
<test_cases>
[
  {
    "test_case_id": "UC1_TC1",
    "title": "Valid Login Credentials",
    "preconditions": "User is not authenticated and has access to PELL portal",
    "postconditions": "User is redirected to Home page",
    "test_steps": [
      {
        "step": "Click on the 'Login' button",
        "expected": "Login form is displayed"
      },
      {
        "step": "Enter valid email and password",
        "expected": "No error messages are displayed"
      },
      {
        "step": "Confirm authentication process",
        "expected": "User is redirected to Home page"
      }
    ],
    "test_type": "Positive",
    "priority": "Hight",
    "use_case_id": "UC1"
  },
  {
    "test_case_id": "UC1_TC2",
    "title": "Invalid Email",
    "preconditions": "User is not authenticated and has access to PELL portal",
    "postconditions": "User is not redirected to Home page",
    "test_steps": [
      {
        "step": "Click on the 'Login' button",
        "expected": "Login form is displayed"
      },
      {
        "step": "Enter invalid email and valid password",
        "expected": "Error message is displayed indicating invalid credentials"
      },
      {
        "step": "Confirm authentication process",
        "expected": "User is not redirected to Home page"
      }
    ],
    "test_type": "Negative",
    "priority": "Medium",
    "use_case_id": "UC1"
  },
  {
    "test_case_id": "UC1_TC3",
    "title": "Invalid Password",
    "preconditions": "User is not authenticated and has access to PELL portal",
    "postconditions": "User is not redirected to Home page",
    "test_steps": [
      {
        "step": "Click on the 'Login' button",
        "expected": "Login form is displayed"
      },
      {
        "step": "Enter valid email and invalid password",
        "expected": "Error message is displayed indicating invalid credentials"
      },
      {
        "step": "Confirm authentication process",
        "expected": "User is not redirected to Home page"
      }
    ],
    "test_type": "Negative",
    "priority": "Medium",
    "use_case_id": "UC1"
  },
  {
    "test_case_id": "UC1_TC4",
    "title": "Empty Email Field",
    "preconditions": "User is not authenticated and has access to PELL portal",
    "postconditions": "User is not redirected to Home page",
    "test_steps": [
      {
        "step": "Click on the 'Login' button",
        "expected": "Login form is displayed"
      },
      {
        "step": "Leave email field empty and enter valid password",
        "expected": "Error message is displayed indicating required field"
      },
      {
        "step": "Confirm authentication process",
        "expected": "User is not redirected to Home page"
      }
    ],
    "test_type": "Boundary",
    "priority": "Low",
    "use_case_id": "UC1"
  },
  {
    "test_case_id": "UC1_TC5",
    "title": "Empty Password Field",
    "preconditions": "User is not authenticated and has access to PELL portal",
    "postconditions": "User is not redirected to Home page",
    "test_steps": [
      {
        "step": "Click on the 'Login' button",
        "expected": "Login form is displayed"
      },
      {
        "step": "Enter valid email and leave empty password field",
        "expected": "Error message is displayed indicating required field"
      },
      {
        "step": "Confirm authentication process",
        "expected": "User is not redirected to Home page"
      }
    ],
    "test_type": "Boundary",
    "priority": "Low",
    "use_case_id": "UC1"
  },
  {
    "test_case_id": "UC1_TC6",
    "title": "SQL Injection Attempt",
    "preconditions": "User is not authenticated and has access to PELL portal",
    "postconditions": "User is not redirected to Home page",
    "test_steps": [
      {
        "step": "Click on the 'Login' button",
        "expected": "Login form is displayed"
      },
      {
        "step": "Enter malicious input in email or password field",
        "expected": "Error message is displayed indicating invalid credentials"
      },
      {
        "step": "Confirm authentication process",
        "expected": "User is not redirected to Home page and no SQL error occurs"
      }
    ],
    "test_type": "Security",
    "priority": "High",
    "use_case_id": "UC1"
  }
]
</test_cases>

Here the test parameters to be used in test scripts:
<test_parameters>
E2E_BASE_URL="http://pell-portal.bologna.enea.it/"
E2E_LOGIN_URL="https://idp.smartcityplatform.enea.it/"
E2E_HOME_URL="" 
E2E_DASHBOARD_URL="" 
E2E_CTS_URL="" 
E2E_LOGIN_EMAIL_ADMIN="test.admin@pell.it"
E2E_LOGIN_PASSWORD_ADMIN="Testadmin01!"
E2E_LOGIN_EMAIL_REGION="test.region@pell.it"
E2E_LOGIN_PASSWORD_REGION="Testregion01!"
</test_parameters>

When creating test scripts, use the following page object models:
<pom>
export class LoginPage {
    readonly page: Page;
    readonly emailInput: Locator;
    readonly passwordInput: Locator;
    readonly loginButton: Locator;
    readonly authenticate: Locator;
    readonly errorMessage: Locator;
  
    constructor(page: Page) {
      this.page = page;
      this.loginButton = page.locator('text="Login"');
      this.emailInput = page.locator('#email');
      this.passwordInput = page.locator('#password');
      this.authenticate = page.locator("#submit");
      this.errorMessage = page.locator('.error-message');
    }
  
    async displayLoginForm() {
        await this.loginButton.click();
    }
  
    async enterEmail(email) {
        await this.emailInput.fill(email);
    }
  
    async enterPassword(password) {
        await this.passwordInput.fill(password);
    }
  
    async getErrorMessage() {
        return await this.errorMessage.textContent();
    }

    async login() {
        await this.authenticate.click();
    }
  }
</pom>

Each test, reuse the following code, without modify it and without include it in the response:
<existing_code>
class TestResultReporter {
    constructor() {
      this.steps = [];
      this.browserName = 'undefined'; // Imposta un valore predefinito per il nome del browser
      this.testCaseId = ''; // Imposta un valore predefinito per il test case ID
      this.testCaseDescription = ''; // Imposta un valore predefinito per la descrizione del test
    }
  
    // Imposta il nome del browser prima dell'inizio del test
    setBrowserName(browserName) {
      this.browserName = browserName;
      console.log(`[DEBUG] Browser impostato: ${this.browserName}`);
    }
  
    // Imposta l'ID del test case e la sua descrizione
    setTestCase(testCaseId, testCaseDescription) {
      this.testCaseId = testCaseId;
      this.testCaseDescription = testCaseDescription;
      console.log(`[DEBUG] Test Case impostato: ${this.testCaseId} - ${this.testCaseDescription}`);
    }
  
  
    // Aggiunge ogni step appena viene eseguito
    addStep(stepId, description, expectedResults, actualResults, passFail, parametersUsed, executionTime) {
      // Se il risultato attuale non è uguale a quello atteso, consideriamo lo step fallito
      if (expectedResults !== actualResults) {
        passFail = 0;  // Imposta il valore di passfail a 0 in caso di errore
      }
  
      const stepData = {
        step_id: stepId,
        step_description: description,
        parameters_used: parametersUsed,
        execution_time: executionTime,
        expected_results: expectedResults,
        actual_results: actualResults,
        pass_fail: passFail,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };
      
      // Aggiunge lo step alla lista locale
      this.steps.push(stepData);
  
      console.log(`[DEBUG] Step aggiunto: ${JSON.stringify(stepData)}`);
  
      // Se lo step fallisce (passFail === 0), termina subito il test
      if (passFail === 0) {
        console.log("[DEBUG] Step fallito, terminazione del test."); 
        this.saveResults();  // Salva immediatamente i risultati
        this.onTestEnd(test, { status: 'failed' });  // Termina il test con stato "failed"
      }
  
    }
  
    // Metodo per assicurarsi che il salvataggio venga fatto anche in caso di errore
    async saveResults() {
      if (this.steps.length > 0) {
        console.log("[DEBUG] Numero di step raccolti per il test:", this.steps.length);
  
        const testCaseId = this.testCaseId || 'undefined'; // Usa l'ID impostato con setTestCase
        const testCaseDescription = this.testCaseDescription || 'undefined'; // Usa la descrizione impostata con setTestCase
        // const testCaseCodeLink = 'https://github.com/example/repo';
        const testNumber = 1;
  
        const testCaseData = {
          test_case_id: testCaseId,
          test_description: testCaseDescription,
          // test_case_code_link: testCaseCodeLink,
          test_number: testNumber,
          browser_name: this.browserName,
          execution_date: new Date().toISOString(),
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        };
  
        console.log(`[DEBUG] Salvataggio dati del test case: ${testCaseId}`);
  
        try {
          // Salva sempre gli step, anche se ci sono stati errori
          await saveTestResults(
            testCaseData.test_case_id,
            testCaseData.test_description,
            // testCaseData.test_case_code_link,
            testCaseData.browser_name,
            this.steps // Salva anche gli step falliti
          );
          console.log(`[DEBUG] Dati del test case "${testCaseId}" salvati correttamente nel database.`);
        } catch (error) {
          console.error(`[DEBUG] Errore durante il salvataggio dei dati per il test case "${testCaseId}":`, error);
        }
      }
  
      // Resetta gli step alla fine per preparare un nuovo test
      this.steps = [];
    }
  
    // Funzione per gestire la fine del test e salvare i risultati
    async onTestEnd(test, result) {
      console.log(`[DEBUG] Test completato: ${test.title} con stato: ${result.status}`);
  
      // Salva i risultati in ogni caso, anche se il test è fallito
      await this.saveResults();
    }
  
  }
  
</existing_code>


Keep in mind the following best practice:
* You generate one test in Playwright for each test case provided, including all steps, using test parameters and page object models provided
* Generate only javascript code, omitting the code provided in the prompt
* Ensure the generated code is syntactically correct JavaScript for Playwright.
* Use only the Page Object Models provided when interacting with the page elements.
* For each test script generated, call the reporter method as in the example below.

<example>
test("UC1_TC1 - Login test with success", async ({page, browserName}) => {
    reporter.setBrowserName(browserName);
    reporter.setTestCase("UC1_TC1 - Login test with success");

    // ... test case step 1
    reporter.addStep('UC1_TC1_ID1', 'Step 1 description', expectedResults, actualResults, passFail, parametersUsed, executionTime);

    // ... test case step 2
    reporter.addStep('UC1_TC1_ID2', 'Step 2 description', expectedResults, actualResults, passFail, parametersUsed, executionTime);

    // ...

    reporter.onTestEnd(test, { status: "passed" });
});
</example>

---------------------------------------------------------------------------------


```javascript
const { test, expect } = require('@playwright/test');
const reporter = new TestReporter();

test("UC1_TC1 - Login test with success", async ({ page, browserName }) => {
    reporter.setBrowserName(browserName);
    reporter.setTestCase("UC1_TC1 - Login test with success");

    const loginPage = new LoginPage(page);

    // Step 1: Navigate to the login page
    await loginPage.navigateTo();
    const expectedResults = "Login page loaded";
    const actualResults = await loginPage.isLoaded();
    let passFail = actualResults ? 1 : 0;
    const parametersUsed = `URL: ${loginPage.url}`;
    const executionTime = new Date().getTime() - (new Date()).getTime(); // Replace with actual execution time
    reporter.addStep('UC1_TC1_ID1', 'Navigate to the login page', expectedResults, actualResults, passFail, parametersUsed, executionTime);

    // Step 2: Enter valid credentials and submit the form
    await loginPage.enterCredentials("username", "password");
    await loginPage.submitForm();
    const expectedResults2 = "Login successful";
    const actualResults2 = await loginPage.isLoginSuccessful();
    passFail = actualResults2 ? 1 : 0;
    const parametersUsed2 = `Username: username, Password: password`;
    const executionTime2 = new Date().getTime() - (new Date()).getTime(); // Replace with actual execution time
    reporter.addStep('UC1_TC1_ID2', 'Enter valid credentials and submit the form', expectedResults2, actualResults2, passFail, parametersUsed2, executionTime2);

    reporter.onTestEnd(test, { status: "passed" });
});

test("UC1_TC2 - Login test with invalid username", async ({ page, browserName }) => {
    reporter.setBrowserName(browserName);
    reporter.setTestCase("UC1_TC2 - Login test with invalid username");

    const loginPage = new LoginPage(page);

    // Step 1: Navigate to the login page
    await loginPage.navigateTo();
    const expectedResults = "Login page loaded";
    const actualResults = await loginPage.isLoaded();
    let passFail = actualResults ? 1 : 0;
    const parametersUsed = `URL: ${loginPage.url}`;
    const executionTime = new Date().getTime() - (new Date()).getTime(); // Replace with actual execution time
    reporter.addStep('UC1_TC2_ID1', 'Navigate to the login page', expectedResults, actualResults, passFail, parametersUsed, executionTime);

    // Step 2: Enter invalid username and valid password, then submit the form
    await loginPage.enterCredentials("invalid_username", "password");
    await loginPage.submitForm();
    const expectedResults2 = "Login failed due to invalid username";
    const actualResults2 = await loginPage.isLoginFailedDueToInvalidUsername();
    passFail = actualResults2 ? 1 : 0;
    const parametersUsed2 = `Username: invalid_username, Password: password`;
    const executionTime2 = new Date().getTime() - (new Date()).getTime(); // Replace with actual execution time
    reporter.addStep('UC1_TC2_ID2', 'Enter invalid username and valid password, then submit the form', expectedResults2, actualResults2, passFail, parametersUsed2, executionTime2);

    reporter.onTestEnd(test, { status: "passed" });
});

test("UC1_TC3 - Login test with invalid password", async ({ page, browserName }) => {
    reporter.setBrowserName(browserName);
    reporter.setTestCase("UC1_TC3 - Login test with invalid password");

    const loginPage = new LoginPage(page);

    // Step 1: Navigate to the login page
    await loginPage.navigateTo();
    const expectedResults = "Login page loaded";
    const actualResults = await loginPage.isLoaded();
    let passFail = actualResults ? 1 : 0;
    const parametersUsed = `URL: ${loginPage.url}`;
    const executionTime = new Date().getTime() - (new Date()).getTime(); // Replace with actual execution time
    reporter.addStep('UC1_TC3_ID1', 'Navigate to the login page', expectedResults, actualResults, passFail, parametersUsed, executionTime);

    // Step 2: Enter valid username and invalid password, then submit the form
    await loginPage.enterCredentials("username", "invalid_password");
    await loginPage.submitForm();
    const expectedResults2 = "Login failed due to invalid password";
    const actualResults2 = await loginPage.isLoginFailedDueToInvalidPassword();
    passFail = actualResults2 ? 1 : 0;
    const parametersUsed2 = `Username: username, Password: invalid_password`;
    const executionTime2 = new Date().getTime() - (new Date()).getTime(); // Replace with actual execution time
    reporter.addStep('UC1_TC3_ID2', 'Enter valid username and invalid password, then submit the form', expectedResults2, actualResults2, passFail, parametersUsed2, executionTime2);

    reporter.onTestEnd(test, { status: "passed" });
});

test("UC1_TC4 - Login test with empty fields", async ({ page, browserName }) => {
    reporter.setBrowserName(browserName);
    reporter.setTestCase("UC1_TC4 - Login test with empty fields");

    const loginPage = new LoginPage(page);

    // Step 1: Navigate to the login page
    await loginPage.navigateTo();
    const expectedResults = "Login page loaded";
    const actualResults = await loginPage.isLoaded();
    let passFail = actualResults ? 1 : 0;
    const parametersUsed = `URL: ${loginPage.url}`;
    const executionTime = new Date().getTime() - (new Date()).getTime(); // Replace with actual execution time
    reporter.addStep('UC1_TC4_ID1', 'Navigate to the login page', expectedResults, actualResults, passFail, parametersUsed, executionTime);

    // Step 2: Submit the form without entering any credentials
    await loginPage.submitForm();
    const expectedResults2 = "Login failed due to empty fields";
    const actualResults2 = await loginPage.isLoginFailedDueToEmptyFields();
    passFail = actualResults2 ? 1 : 0;
    const parametersUsed2 = `No username or password entered`;
    const executionTime2 = new Date().getTime() - (new Date()).getTime(); // Replace with actual execution time
    reporter.addStep('UC1_TC4_ID2', 'Submit the form without entering any credentials', expectedResults2, actualResults2, passFail, parametersUsed2, executionTime2);

    reporter.onTestEnd(test, { status: "passed" });
});
```